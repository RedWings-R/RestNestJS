import { HttpException, HttpStatus, Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { Response } from 'express';
import { CreateTacheDto } from './dto/create-tache.dto';
import { UpdateTacheDto } from './dto/update-tache.dto';
import { Tache } from './entities/tache.entity';
import { RelationTacheDto } from './dto/relation-tache.dto';

@Injectable()
export class TacheService {
  constructor(@InjectRepository(Tache) private readonly tachesRepository: Repository<Tache>,){
  }

  /////////////////////////////////////////////////////////////////////////////////////////////
  /////////////////////////////////////////////////////////////////////////////////////////////
  create(createTacheDto: CreateTacheDto): Promise<Tache> {
    const tacheNew = new Tache();
    tacheNew.description = createTacheDto.description;
    tacheNew.date_creation = createTacheDto.date_creation;
    tacheNew.cloturer = createTacheDto.cloturer;
    tacheNew.utilisateur = createTacheDto.utilisateur;
    return this.tachesRepository.save(tacheNew).catch((err) => {
      throw new HttpException(err.sqlMessage,HttpStatus.UNAUTHORIZED);
    });
  }
  /////////////////////////////////////////////////////////////////////////////////////////////
  /////////////////////////////////////////////////////////////////////////////////////////////

  /////////////////////////////////////////////////////////////////////////////////////////////
  /////////////////////////////////////////////////////////////////////////////////////////////
  async findTacheWithRelationByID(id: number,relationTacheDto: RelationTacheDto): Promise<Tache> {
    let tache_ = await this.tachesRepository.findOne(id,{relations:relationTacheDto.relations});
    if(tache_ === undefined){
      throw new HttpException("Aucun tache récupéré",HttpStatus.NOT_FOUND);
    }else{
      return tache_;
    }
  }
  /////////////////////////////////////////////////////////////////////////////////////////////
  /////////////////////////////////////////////////////////////////////////////////////////////

  /////////////////////////////////////////////////////////////////////////////////////////////
  /////////////////////////////////////////////////////////////////////////////////////////////
  async findAll():Promise<Tache[]> {
    let taches_ = await this.tachesRepository.find();
    if(taches_.length === 0){
      throw new HttpException("Aucune tache récupéré",HttpStatus.NOT_FOUND);
    }else{
      return taches_;
    }
  }
  /////////////////////////////////////////////////////////////////////////////////////////////
  /////////////////////////////////////////////////////////////////////////////////////////////

  /////////////////////////////////////////////////////////////////////////////////////////////
  /////////////////////////////////////////////////////////////////////////////////////////////
  async findOne(id: number):Promise<Tache> {
    let tache_ = await this.tachesRepository.findOne(id);
    if(tache_ === undefined){
      throw new HttpException("Aucune tache récupéré",HttpStatus.NOT_FOUND);
    }else{
      return tache_;
    }
  }
  /////////////////////////////////////////////////////////////////////////////////////////////
  /////////////////////////////////////////////////////////////////////////////////////////////

  /////////////////////////////////////////////////////////////////////////////////////////////
  /////////////////////////////////////////////////////////////////////////////////////////////
  async update(id: number, updateTacheDto: UpdateTacheDto): Promise<Tache>{
    let tache_ = await this.tachesRepository.findOne(id);
    if(tache_ === undefined){
      throw new HttpException("Tache inconnue",HttpStatus.NOT_FOUND);
    }
    tache_.description = updateTacheDto.description;
    tache_.date_creation = updateTacheDto.date_creation;
    tache_.cloturer = updateTacheDto.cloturer;
    tache_.utilisateur = updateTacheDto.utilisateur;
    tache_ = await this.tachesRepository.save(tache_).then(()=>{
      return this.tachesRepository.findOne(id).catch((err) => {
        throw new HttpException(err.sqlMessage,HttpStatus.NOT_FOUND);
      });
    }).catch((err) => {
      throw new HttpException(err.sqlMessage,HttpStatus.NOT_FOUND);
    });
    
    return tache_;
  }
  /////////////////////////////////////////////////////////////////////////////////////////////
  /////////////////////////////////////////////////////////////////////////////////////////////

  /////////////////////////////////////////////////////////////////////////////////////////////
  /////////////////////////////////////////////////////////////////////////////////////////////
  async remove(id: number,res: Response): Promise<void> {
    this.tachesRepository.delete(id).then((rslt) => {
      console.log(rslt.affected)
      if(rslt.affected){
        res.status(HttpStatus.OK).send({"Message":"Suppression réussi"});
      }else{
        res.status(HttpStatus.NOT_FOUND).send({
          "Message":"Echec suppression",
           "Error":"Tache inconnue"
          });
      }
    });
  }
  /////////////////////////////////////////////////////////////////////////////////////////////
  /////////////////////////////////////////////////////////////////////////////////////////////
}
